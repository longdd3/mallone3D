{"id":"Gy0z","dependencies":[{"name":"D:\\Web Development\\mallone3D\\package.json","includedInParent":true,"mtime":1680117085946},{"name":"D:\\Web Development\\mallone3D\\node_modules\\three\\package.json","includedInParent":true,"mtime":1680117024254},{"name":"three","loc":{"line":9,"column":7,"index":120},"parent":"D:\\Web Development\\mallone3D\\node_modules\\three\\examples\\jsm\\loaders\\DRACOLoader.js","resolved":"D:\\Web Development\\mallone3D\\node_modules\\three\\build\\three.module.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.DRACOLoader = void 0;\nvar _three = require(\"three\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, \"prototype\", { writable: false }); return Constructor; }\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return _typeof(key) === \"symbol\" ? key : String(key); }\nfunction _toPrimitive(input, hint) { if (_typeof(input) !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (_typeof(res) !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, \"prototype\", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } else if (call !== void 0) { throw new TypeError(\"Derived constructors may only return object or undefined\"); } return _assertThisInitialized(self); }\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\nvar _taskCache = new WeakMap();\nvar DRACOLoader = /*#__PURE__*/function (_Loader) {\n  _inherits(DRACOLoader, _Loader);\n  var _super = _createSuper(DRACOLoader);\n  function DRACOLoader(manager) {\n    var _this;\n    _classCallCheck(this, DRACOLoader);\n    _this = _super.call(this, manager);\n    _this.decoderPath = '';\n    _this.decoderConfig = {};\n    _this.decoderBinary = null;\n    _this.decoderPending = null;\n    _this.workerLimit = 4;\n    _this.workerPool = [];\n    _this.workerNextTaskID = 1;\n    _this.workerSourceURL = '';\n    _this.defaultAttributeIDs = {\n      position: 'POSITION',\n      normal: 'NORMAL',\n      color: 'COLOR',\n      uv: 'TEX_COORD'\n    };\n    _this.defaultAttributeTypes = {\n      position: 'Float32Array',\n      normal: 'Float32Array',\n      color: 'Float32Array',\n      uv: 'Float32Array'\n    };\n    return _this;\n  }\n  _createClass(DRACOLoader, [{\n    key: \"setDecoderPath\",\n    value: function setDecoderPath(path) {\n      this.decoderPath = path;\n      return this;\n    }\n  }, {\n    key: \"setDecoderConfig\",\n    value: function setDecoderConfig(config) {\n      this.decoderConfig = config;\n      return this;\n    }\n  }, {\n    key: \"setWorkerLimit\",\n    value: function setWorkerLimit(workerLimit) {\n      this.workerLimit = workerLimit;\n      return this;\n    }\n  }, {\n    key: \"load\",\n    value: function load(url, onLoad, onProgress, onError) {\n      var _this2 = this;\n      var loader = new _three.FileLoader(this.manager);\n      loader.setPath(this.path);\n      loader.setResponseType('arraybuffer');\n      loader.setRequestHeader(this.requestHeader);\n      loader.setWithCredentials(this.withCredentials);\n      loader.load(url, function (buffer) {\n        _this2.parse(buffer, onLoad, onError);\n      }, onProgress, onError);\n    }\n  }, {\n    key: \"parse\",\n    value: function parse(buffer, onLoad, onError) {\n      this.decodeDracoFile(buffer, onLoad, null, null, _three.SRGBColorSpace).catch(onError);\n    }\n  }, {\n    key: \"decodeDracoFile\",\n    value: function decodeDracoFile(buffer, callback, attributeIDs, attributeTypes, vertexColorSpace = _three.LinearSRGBColorSpace) {\n      var taskConfig = {\n        attributeIDs: attributeIDs || this.defaultAttributeIDs,\n        attributeTypes: attributeTypes || this.defaultAttributeTypes,\n        useUniqueIDs: !!attributeIDs,\n        vertexColorSpace: vertexColorSpace\n      };\n      return this.decodeGeometry(buffer, taskConfig).then(callback);\n    }\n  }, {\n    key: \"decodeGeometry\",\n    value: function decodeGeometry(buffer, taskConfig) {\n      var _this3 = this;\n      var taskKey = JSON.stringify(taskConfig);\n\n      // Check for an existing task using this buffer. A transferred buffer cannot be transferred\n      // again from this thread.\n      if (_taskCache.has(buffer)) {\n        var cachedTask = _taskCache.get(buffer);\n        if (cachedTask.key === taskKey) {\n          return cachedTask.promise;\n        } else if (buffer.byteLength === 0) {\n          // Technically, it would be possible to wait for the previous task to complete,\n          // transfer the buffer back, and decode again with the second configuration. That\n          // is complex, and I don't know of any reason to decode a Draco buffer twice in\n          // different ways, so this is left unimplemented.\n          throw new Error('THREE.DRACOLoader: Unable to re-decode a buffer with different ' + 'settings. Buffer has already been transferred.');\n        }\n      }\n\n      //\n\n      var worker;\n      var taskID = this.workerNextTaskID++;\n      var taskCost = buffer.byteLength;\n\n      // Obtain a worker and assign a task, and construct a geometry instance\n      // when the task completes.\n      var geometryPending = this._getWorker(taskID, taskCost).then(function (_worker) {\n        worker = _worker;\n        return new Promise(function (resolve, reject) {\n          worker._callbacks[taskID] = {\n            resolve: resolve,\n            reject: reject\n          };\n          worker.postMessage({\n            type: 'decode',\n            id: taskID,\n            taskConfig: taskConfig,\n            buffer: buffer\n          }, [buffer]);\n\n          // this.debug();\n        });\n      }).then(function (message) {\n        return _this3._createGeometry(message.geometry);\n      });\n\n      // Remove task from the task list.\n      // Note: replaced '.finally()' with '.catch().then()' block - iOS 11 support (#19416)\n      geometryPending.catch(function () {\n        return true;\n      }).then(function () {\n        if (worker && taskID) {\n          _this3._releaseTask(worker, taskID);\n\n          // this.debug();\n        }\n      });\n\n      // Cache the task result.\n      _taskCache.set(buffer, {\n        key: taskKey,\n        promise: geometryPending\n      });\n      return geometryPending;\n    }\n  }, {\n    key: \"_createGeometry\",\n    value: function _createGeometry(geometryData) {\n      var geometry = new _three.BufferGeometry();\n      if (geometryData.index) {\n        geometry.setIndex(new _three.BufferAttribute(geometryData.index.array, 1));\n      }\n      for (var i = 0; i < geometryData.attributes.length; i++) {\n        var result = geometryData.attributes[i];\n        var name = result.name;\n        var array = result.array;\n        var itemSize = result.itemSize;\n        var attribute = new _three.BufferAttribute(array, itemSize);\n        if (name === 'color') {\n          this._assignVertexColorSpace(attribute, result.vertexColorSpace);\n        }\n        geometry.setAttribute(name, attribute);\n      }\n      return geometry;\n    }\n  }, {\n    key: \"_assignVertexColorSpace\",\n    value: function _assignVertexColorSpace(attribute, inputColorSpace) {\n      // While .drc files do not specify colorspace, the only 'official' tooling\n      // is PLY and OBJ converters, which use sRGB. We'll assume sRGB when a .drc\n      // file is passed into .load() or .parse(). GLTFLoader uses internal APIs\n      // to decode geometry, and vertex colors are already Linear-sRGB in there.\n\n      if (inputColorSpace !== _three.SRGBColorSpace) return;\n      var _color = new _three.Color();\n      for (var i = 0, il = attribute.count; i < il; i++) {\n        _color.fromBufferAttribute(attribute, i).convertSRGBToLinear();\n        attribute.setXYZ(i, _color.r, _color.g, _color.b);\n      }\n    }\n  }, {\n    key: \"_loadLibrary\",\n    value: function _loadLibrary(url, responseType) {\n      var loader = new _three.FileLoader(this.manager);\n      loader.setPath(this.decoderPath);\n      loader.setResponseType(responseType);\n      loader.setWithCredentials(this.withCredentials);\n      return new Promise(function (resolve, reject) {\n        loader.load(url, resolve, undefined, reject);\n      });\n    }\n  }, {\n    key: \"preload\",\n    value: function preload() {\n      this._initDecoder();\n      return this;\n    }\n  }, {\n    key: \"_initDecoder\",\n    value: function _initDecoder() {\n      var _this4 = this;\n      if (this.decoderPending) return this.decoderPending;\n      var useJS = (typeof WebAssembly === \"undefined\" ? \"undefined\" : _typeof(WebAssembly)) !== 'object' || this.decoderConfig.type === 'js';\n      var librariesPending = [];\n      if (useJS) {\n        librariesPending.push(this._loadLibrary('draco_decoder.js', 'text'));\n      } else {\n        librariesPending.push(this._loadLibrary('draco_wasm_wrapper.js', 'text'));\n        librariesPending.push(this._loadLibrary('draco_decoder.wasm', 'arraybuffer'));\n      }\n      this.decoderPending = Promise.all(librariesPending).then(function (libraries) {\n        var jsContent = libraries[0];\n        if (!useJS) {\n          _this4.decoderConfig.wasmBinary = libraries[1];\n        }\n        var fn = DRACOWorker.toString();\n        var body = ['/* draco decoder */', jsContent, '', '/* worker */', fn.substring(fn.indexOf('{') + 1, fn.lastIndexOf('}'))].join('\\n');\n        _this4.workerSourceURL = URL.createObjectURL(new Blob([body]));\n      });\n      return this.decoderPending;\n    }\n  }, {\n    key: \"_getWorker\",\n    value: function _getWorker(taskID, taskCost) {\n      var _this5 = this;\n      return this._initDecoder().then(function () {\n        if (_this5.workerPool.length < _this5.workerLimit) {\n          var _worker2 = new Worker(_this5.workerSourceURL);\n          _worker2._callbacks = {};\n          _worker2._taskCosts = {};\n          _worker2._taskLoad = 0;\n          _worker2.postMessage({\n            type: 'init',\n            decoderConfig: _this5.decoderConfig\n          });\n          _worker2.onmessage = function (e) {\n            var message = e.data;\n            switch (message.type) {\n              case 'decode':\n                _worker2._callbacks[message.id].resolve(message);\n                break;\n              case 'error':\n                _worker2._callbacks[message.id].reject(message);\n                break;\n              default:\n                console.error('THREE.DRACOLoader: Unexpected message, \"' + message.type + '\"');\n            }\n          };\n          _this5.workerPool.push(_worker2);\n        } else {\n          _this5.workerPool.sort(function (a, b) {\n            return a._taskLoad > b._taskLoad ? -1 : 1;\n          });\n        }\n        var worker = _this5.workerPool[_this5.workerPool.length - 1];\n        worker._taskCosts[taskID] = taskCost;\n        worker._taskLoad += taskCost;\n        return worker;\n      });\n    }\n  }, {\n    key: \"_releaseTask\",\n    value: function _releaseTask(worker, taskID) {\n      worker._taskLoad -= worker._taskCosts[taskID];\n      delete worker._callbacks[taskID];\n      delete worker._taskCosts[taskID];\n    }\n  }, {\n    key: \"debug\",\n    value: function debug() {\n      console.log('Task load: ', this.workerPool.map(function (worker) {\n        return worker._taskLoad;\n      }));\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      for (var i = 0; i < this.workerPool.length; ++i) {\n        this.workerPool[i].terminate();\n      }\n      this.workerPool.length = 0;\n      if (this.workerSourceURL !== '') {\n        URL.revokeObjectURL(this.workerSourceURL);\n      }\n      return this;\n    }\n  }]);\n  return DRACOLoader;\n}(_three.Loader);\n/* WEB WORKER */\nexports.DRACOLoader = DRACOLoader;\nfunction DRACOWorker() {\n  var decoderConfig;\n  var decoderPending;\n  onmessage = function onmessage(e) {\n    var message = e.data;\n    switch (message.type) {\n      case 'init':\n        decoderConfig = message.decoderConfig;\n        decoderPending = new Promise(function (resolve /*, reject*/) {\n          decoderConfig.onModuleLoaded = function (draco) {\n            // Module is Promise-like. Wrap before resolving to avoid loop.\n            resolve({\n              draco: draco\n            });\n          };\n          DracoDecoderModule(decoderConfig); // eslint-disable-line no-undef\n        });\n\n        break;\n      case 'decode':\n        var buffer = message.buffer;\n        var taskConfig = message.taskConfig;\n        decoderPending.then(function (module) {\n          var draco = module.draco;\n          var decoder = new draco.Decoder();\n          try {\n            var geometry = decodeGeometry(draco, decoder, new Int8Array(buffer), taskConfig);\n            var buffers = geometry.attributes.map(function (attr) {\n              return attr.array.buffer;\n            });\n            if (geometry.index) buffers.push(geometry.index.array.buffer);\n            self.postMessage({\n              type: 'decode',\n              id: message.id,\n              geometry: geometry\n            }, buffers);\n          } catch (error) {\n            console.error(error);\n            self.postMessage({\n              type: 'error',\n              id: message.id,\n              error: error.message\n            });\n          } finally {\n            draco.destroy(decoder);\n          }\n        });\n        break;\n    }\n  };\n  function decodeGeometry(draco, decoder, array, taskConfig) {\n    var attributeIDs = taskConfig.attributeIDs;\n    var attributeTypes = taskConfig.attributeTypes;\n    var dracoGeometry;\n    var decodingStatus;\n    var geometryType = decoder.GetEncodedGeometryType(array);\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      dracoGeometry = new draco.Mesh();\n      decodingStatus = decoder.DecodeArrayToMesh(array, array.byteLength, dracoGeometry);\n    } else if (geometryType === draco.POINT_CLOUD) {\n      dracoGeometry = new draco.PointCloud();\n      decodingStatus = decoder.DecodeArrayToPointCloud(array, array.byteLength, dracoGeometry);\n    } else {\n      throw new Error('THREE.DRACOLoader: Unexpected geometry type.');\n    }\n    if (!decodingStatus.ok() || dracoGeometry.ptr === 0) {\n      throw new Error('THREE.DRACOLoader: Decoding failed: ' + decodingStatus.error_msg());\n    }\n    var geometry = {\n      index: null,\n      attributes: []\n    };\n\n    // Gather all vertex attributes.\n    for (var attributeName in attributeIDs) {\n      var attributeType = self[attributeTypes[attributeName]];\n      var attribute = void 0;\n      var attributeID = void 0;\n\n      // A Draco file may be created with default vertex attributes, whose attribute IDs\n      // are mapped 1:1 from their semantic name (POSITION, NORMAL, ...). Alternatively,\n      // a Draco file may contain a custom set of attributes, identified by known unique\n      // IDs. glTF files always do the latter, and `.drc` files typically do the former.\n      if (taskConfig.useUniqueIDs) {\n        attributeID = attributeIDs[attributeName];\n        attribute = decoder.GetAttributeByUniqueId(dracoGeometry, attributeID);\n      } else {\n        attributeID = decoder.GetAttributeId(dracoGeometry, draco[attributeIDs[attributeName]]);\n        if (attributeID === -1) continue;\n        attribute = decoder.GetAttribute(dracoGeometry, attributeID);\n      }\n      var attributeResult = decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute);\n      if (attributeName === 'color') {\n        attributeResult.vertexColorSpace = taskConfig.vertexColorSpace;\n      }\n      geometry.attributes.push(attributeResult);\n    }\n\n    // Add index.\n    if (geometryType === draco.TRIANGULAR_MESH) {\n      geometry.index = decodeIndex(draco, decoder, dracoGeometry);\n    }\n    draco.destroy(dracoGeometry);\n    return geometry;\n  }\n  function decodeIndex(draco, decoder, dracoGeometry) {\n    var numFaces = dracoGeometry.num_faces();\n    var numIndices = numFaces * 3;\n    var byteLength = numIndices * 4;\n    var ptr = draco._malloc(byteLength);\n    decoder.GetTrianglesUInt32Array(dracoGeometry, byteLength, ptr);\n    var index = new Uint32Array(draco.HEAPF32.buffer, ptr, numIndices).slice();\n    draco._free(ptr);\n    return {\n      array: index,\n      itemSize: 1\n    };\n  }\n  function decodeAttribute(draco, decoder, dracoGeometry, attributeName, attributeType, attribute) {\n    var numComponents = attribute.num_components();\n    var numPoints = dracoGeometry.num_points();\n    var numValues = numPoints * numComponents;\n    var byteLength = numValues * attributeType.BYTES_PER_ELEMENT;\n    var dataType = getDracoDataType(draco, attributeType);\n    var ptr = draco._malloc(byteLength);\n    decoder.GetAttributeDataArrayForAllPoints(dracoGeometry, attribute, dataType, byteLength, ptr);\n    var array = new attributeType(draco.HEAPF32.buffer, ptr, numValues).slice();\n    draco._free(ptr);\n    return {\n      name: attributeName,\n      array: array,\n      itemSize: numComponents\n    };\n  }\n  function getDracoDataType(draco, attributeType) {\n    switch (attributeType) {\n      case Float32Array:\n        return draco.DT_FLOAT32;\n      case Int8Array:\n        return draco.DT_INT8;\n      case Int16Array:\n        return draco.DT_INT16;\n      case Int32Array:\n        return draco.DT_INT32;\n      case Uint8Array:\n        return draco.DT_UINT8;\n      case Uint16Array:\n        return draco.DT_UINT16;\n      case Uint32Array:\n        return draco.DT_UINT32;\n    }\n  }\n}"},"sourceMaps":null,"error":null,"hash":"7afb1d7b45280d6c43202dc935cd523e","cacheData":{"env":{}}}